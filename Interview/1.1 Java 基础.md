# Java 基础


## 1. 面向对象的特征：继承、封装和多态
### 继 承
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表
述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。
新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新
类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可
以修改或增加新的方法使之更适合特殊的需要。  
好处：1.提高了代码的复用性。  2.让类与类之间产生了关系，提供了另一个特征多态的前提。

在方法覆盖时，注意两点：  
1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。  
2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)   

### 封 装
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象
计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，
这些对象通过一个受保护的接口访问其他对象。  
是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。  
好处：将变化隔离；便于使用；提高重用性；安全性。  
封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。 

### 多 态
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和
包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的
解决了应用程序函数同名问题。  
体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat(); 多态的好处：提高了程序的扩展性。  
多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性) 
多态的前提：  1：必须要有关系，比如继承、或者实现。  2：通常会有覆盖操作。

### 抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前
目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时
不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。

## 2. final, finally, finalize 的区别

### final
修饰符（关键字）如果一个类被声明为 final，意味着它不能再
派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract
的，又被声明为 final 的。将变量或方法声明为 final，可以保证它们在使用
中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用
中只能读取，不可修改。被声明为 final 的方法也同样只能使用，不能重载

### finally
再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个
异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块
（如果有的话）。

### finalize
方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将

对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定
这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此
所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其
他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用
的。


## 3. Exception、Error、运行时异常与一般异常有何异同
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。


Throwable是所有Java程序中错误处理的父类，有两种资类：Error和Exception。

 Error：表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。Error类体系描述了Java运行系统中的内部错误以及资源耗尽的情形.应用程序不应该抛出这种类型的对象(一般是由虚拟机抛出).假如出现这种错误,除了尽力使程序安全退出外,在其他方面是无能为力的.

       Exception：表示可恢复的例外，这是可捕捉到的。

Java提供了两类主要的异常:runtime exception和checked exception。checked 异常也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。这类异常一般是外部错误,例如试图从文件尾后读取数据等,这并不是程序本身的错误,而是在应用环境中出现的外部错误.

但是另外一种异常：runtime exception，也称运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。RuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等.处理RuntimeException的原则是:假如出现RuntimeException,那么一定是程序员的错误.例如,可以通过检查数组下标和数组边界来避免数组越界访问异常.

出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被Catch块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。
如果不想终止，则必须扑捉所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。在这个场景这样处理可能是一个比较好的应用，但并不代表在所有的场景你都应该如此。如果在其它场景，遇到了一些错误，如果退出程序比较好，这时你就可以不太理会运行时异常，或者是通过对异常的处理显式的控制程序退出。异常处理的目标之一就是为了把程序从异常中恢复出来。


## 4. 请写出5种常见到的 runtime exception
```
nullpoirterex
outboundof
打断
classnotfound
noclassdef

框架中的


```

## 5. int 和 Integer 有什么区别，Integer的值缓存范围




## 6. 包装类，装箱和拆箱

## 7. String、StringBuilder、StringBuffer


线程安全的原理

## 8. 重载和重写的区别
### 重载(Overloading)
重载Overloading是一个类中多态性的一种表现
1. 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。
2. Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。
3. 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。

### 重写（Overriding）(覆盖)
1. 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。
2. 若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。

### 重写方法的规则：
1. 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。
2. 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。
3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private）
4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：
父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。

### 而重载的规则：
1. 必须具有不同的参数列表；
2. 可以有不责骂的返回类型，只要参数列表不同就可以了；
3. 可以有不同的访问修饰符；
4. 可以抛出不同的异常；

## 9. 抽象类和接口有什么区别

抽象类和接口的区别：  
1：抽象类只能被继承，而且只能单继承。  接口需要被实现，而且可以多实现。   
2：抽象类中可以定义非抽象方法，子类可以直接继承使用。  接口中都有抽象方法，需要子类去实现。 
3：抽象类使用的是  is a 关系。  接口使用的 like a 关系。  
4：抽象类的成员修饰符可以自定义。  接口中的成员修饰符是固定的。全都是public的。

Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
类可以实现很多个接口，但是只能继承一个抽象类
类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
抽象类可以在不提供接口方法实现的情况下实现接口。
Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。

## 10. 说说反射的用途及实现

    反射的应用很多，很多框架都有用到
    spring 的 ioc/di 也是反射....
    javaBean和jsp之间调用也是反射....
    struts的 FormBean 和页面之间...也是通过反射调用....
    JDBC 的 classForName()也是反射.....
    hibernate的 find(Class clazz) 也是反射....


## 11. 说说自定义注解的场景及实现




## 12. HTTP请求的GET与POST方式的区别

## 13. Session与Cookie区别

## 14. 列出自己常用的JDK包

## 15. MVC设计思想

## 16. equals与==的区别

## 17. hashCode和equals方法的区别与联系

## 18. 什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用

## 19. Object类中常见的方法，为什么wait  notify会放在Object里边？

## 20. Java的平台无关性如何体现出来的

## 21. JDK和JRE的区别

## 22. Java 8有哪些新特性




## 数据类型
1. 基本数据类型：byte、short、int、long、float、double、char、boolean   
2. 引用数据类型: 数组、类、接口。  
    级别从低到高为：byte,char,short(这三个平级)-->int-->float-->long-->double 
    自动类型转换：从低级别到高级别，系统自动转的
    强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量

## 内存
java分了5片内存。  
1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。  
栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；  只要数据运算完成所在的区域结束，该数据就会被释放。  
堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。  
1：每一个实体都有内存首地址值。  
2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。  
3：垃圾回收机制。


## 什么是值传递和引用传递？
值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.
引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.
一般认为,java内的传递都是值传递.

## 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。

答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。

String str = new String(“hello”);

上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。

补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。


## 内部类

## 异常

## 多线程
进程：正在进行中的程序。其实进程就是一个应用程序运行时的内存分配空间。
线程：其实就是进程中一个程序执行控制单元，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。
一个进程至少有一个线程在运行，当一个进程中出现多个线程时，就称这个应用程序是多线程应用程序，每个线程在栈区中都有自己的执行空间，自己的方法区、自己的变量。
jvm在启动的时，首先有一个主线程，负责程序的执行，调用的是main函数。主线程执行的代码都在main方法中。
当产生垃圾时，收垃圾的动作，是不需要主线程来完成，因为这样，会出现主线程中的代码执行会停止，会去运行垃圾回收器代码，效率较低，所以由单独一个线程来负责垃圾回收。 

每个对象除了属性和方法，都有一个monitor（互斥锁标记），用来将这个对象交给一个线程，只有拿到monitor的线程才能够访问这个对象。

一个线程可以拿到多个锁标记，一个对象最多只能将monitor给一个线程。
Synchronized是以牺牲程序运行的效率为代价的，因此应该尽量控制互斥代码块的范围。

线程因为未拿到锁标记而发生的阻塞不同于前面五个基本状态中的阻塞，称为锁池。
每个对象都有自己的一个锁池的空间，用于放置等待运行的线程。
这些线程中哪个线程拿到锁标记由系统决定。

锁标记如果过多，就会出现线程等待其他线程释放锁标记，而又都不释放自己的锁标记供其他线程运行的状况。就是死锁。
死锁的问题通过线程间的通信的方式进行解决。
线程间通信机制实际上也就是协调机制。
线程间通信使用的空间称之为对象的等待队列，则个队列也是属于对象的空间的。
Notify()
如果一个线程调用对象的notify()，就是通知对象等待队列的一个线程出列。进入锁池。如果使用notifyall()则通知等待队列中所有的线程出列。

释放锁标记只有在Synchronized代码结束或者调用wait()。
注意锁标记是自己不会自动释放，必须有通知。
注意在程序中判定一个条件是否成立时要注意使用WHILE要比使用IF要严密。

一般来说，主方法main()结束的时候线程结束，可是也可能出现需要中断线程的情况。对于多线程一般每个线程都是一个循环，如果中断线程我们必须想办法使其退出。

如果主方法main()想结束阻塞中的线程（比如sleep或wait）
那么我们可以从其他进程对线程对象调用interrupt()。用于对阻塞（或锁池）会抛出例外Interrupted Exception。
这个例外会使线程中断并执行catch中代码。

多线程中的重点：实现多线程的两种方式，Synchronized,以及生产者和消费者问题（ProducerConsumer.java文件）。



## Socket

Socket通信的步骤
1. 创建ServerSocket和Socket
2. 打开连接到Socket的输入/输出流
3. 按照协议对Socket进行读/写操作
4. 关闭输入输出流、关闭Socket

服务器端：
1. 创建ServerSocket对象，绑定监听端口
2. 通过accept()方法监听客户端请求
3. 连接建立后，通过输入流读取客户端发送的请求信息
4. 通过输出流向客户端发送乡音信息
5. 关闭相关资源

客户端：
1. 创建Socket对象，指明需要连接的服务器的地址和端口号
2. 连接建立后，通过输出流想服务器端发送请求信息
3. 通过输入流获取服务器响应的信息
4. 关闭响应资源 


Server.java
``` java
int port = 8919;
ServerSocket server = new ServerSocket(port);
Socket socket = server.accept();
Reader reader = new InputStreamReader(socket.getInputStream());
// 读写操作
.
.
.
```

client.java
``` java
String host = "127.0.0.1";
int port = 8919;
try {
    Socket client = new Socket(host, port);
    Writer writer = new OutputStreamWriter(client.getOutputStream());
    writer.write("Hello From Client");
    writer.flush();
    writer.close();
    client.close();
} catch (IOException e) {
    e.printStackTrace();
}
```

## Java 关键字
### native（本地）
native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。

### strictfp（严格,精准）
strictfp 的意思是FP-strict，也就是说精确浮点的意思。在Java虚拟机进行浮点运算时，如果没有指定strictfp关键字时，Java的编译器以及运 行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令你满意。而一旦使用了strictfp来声明一个 类、接口或者方法时，那么所声明的范围内Java的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。因此如果你想让你的浮点运算更加精确， 而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字strictfp。

### transient（短暂）
Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。

当对象被序列化时（写入字节序列到目标文件）时，transient阻止实例中那些用此关键字声明的变量持久化；

### volatile（易失）
volatile 也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变 化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

### 保留字
`const` `goto`  

### 特别注意 
`true`、`false`、`null` 是常量

## JDBC

``` java 
String url = "jdbc:mysql://localhost:3306/test";
String username = "root";
String password = "root";
try{
    Connection con = DriverManager.getConnection(url , username , password ); 
    Statement stmt = con.createStatement();
    // PreparedStatement pstmt = con.prepareStatement(sql);
    // CallableStatement cstmt = con.prepareCall("{CALL demoSp(? , ?)}");
    ResultSet rs = stmt.executeQuery("SELECT * FROM ...");
    int rows = stmt.executeUpdate("INSERT INTO ...");
    boolean flag = stmt.execute(String sql);
}catch(Exception e){
    System.out.println("数据库连接失败！");   
    e.printStackTrace();
}
```

## Synchronized
当同步函数被static修饰时，这时的同步用的是哪个锁呢？
静态函数在加载时所属于类，这时有可能还没有该类产生的对象，但是该类的字节码文件加载进内存就已经被封装成了对象，这个对象就是该类的字节码文件对象。
所以静态加载时，只有一个对象存在，那么静态同步函数就使用的这个对象。
这个对象就是 类名.class

Lock接口：多线程在JDK1.5版本升级时，推出一个接口Lock接口。
解决线程安全问题使用同步的形式，(同步代码块，要么同步函数)其实最终使用的都是锁机制。

到了后期版本，直接将锁封装成了对象。线程进入同步就是具备了锁，执行完，离开同步，就是释放了锁。
在后期对锁的分析过程中，发现，获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。

所以同步是隐示的锁操作，而Lock对象是显示的锁操作，它的出现就替代了同步。

而现在锁是指定对象Lock。所以查找等待唤醒机制方式需要通过Lock接口来完成。而Lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到了一个对象中。这个对象就是Condition，将Object中的三个方法进行单独的封装。并提供了功能一致的方法 await()、signal()、signalAll()体现新版本对象的好处。
< java.util.concurrent.locks > Condition接口：await()、signal()、signalAll()；

``` java
class BoundedBuffer {
    final Lock lock = new ReentrantLock();
    final Condition notFull  = lock.newCondition(); 
    final Condition notEmpty = lock.newCondition(); 
    final Object[] items = new Object[100];
    int putptr, takeptr, count;
    
    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length) 
            notFull.await();
            items[putptr] = x; 
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal();
        }finally {
            lock.unlock();
        }
    }
    
    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) 
            notEmpty.await();
            Object x = items[takeptr]; 
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal();
            return x;
        }finally {
            lock.unlock();
        }
    } 
}
```

## File

## 作用域修饰符
| 作用域    | 当前类 | 同包  | 子孙类  | 所有  |
| :-------: | :----: | :---: | :----: | :---: |
| public    | √      | √     | √      | √     |
| protected | √      | √     | √      | ×     |
| default   | √      | √     | ×      | ×     |
| private   | √      | ×     | ×      | ×     |


